# Learn Front-end <br/>
<br/>

## 이 문서를 읽기 전에

- 현재 메모를 옮겨오거나 추가하고 있습니다.
- 아직 목차의 순서가 정렬되지 않았습니다, 같은 언어의 개념이라도 순서가 뒤죽박죽 일 수 있습니다.
- 공부하고 있는 개념이기에 정확한 사실에 기반하려 노력했으나, 아닐 수도 있습니다. 다른 자료와 비교해서 봐주세요.
- 하단에 인용하거나 개념을 이해하는데 도움이 되었던 링크를 올리고 있지만 누락되었을 수도 있습니다.
- 온전히 공부하고 이해하기 위한 목적의 문서입니다. 그점 양해 부탁드립니다.

<br/>

## 대목차

- [Javascript](https://github.com/ye-r1/LearnFrontEnd/blob/main/Javascript.md#%EC%9D%B4-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%97%90)
- [React](https://github.com/ye-r1/LearnFrontEnd/blob/main/React.md#%EC%9D%B4-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%97%90)
- [Typescript](https://github.com/ye-r1/LearnFrontEnd/blob/main/Typescript.md#%EC%9D%B4-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%97%90)

<br/>

## 소목차

- [1. JSX](#1-jsx)
- [2. React](#2-react)
- [3. FLUX](#3-flux)
- [4. 서버사이드렌더링, 클라이언트사이드렌더링](#4-서버사이드렌더링-클라이언트사이드렌더링)
- [5. 사이트 동작방식](#5-사이트-동작방식)
- [6. 리액트 성능개선 방법](#6-리액트-성능개선-방법)
- [7. 프레임워크, 라이브러리](#7-프레임워크-라이브러리)
- [8. 함수형 컴포넌트, 클래스형 컴포넌트](#8-함수형-컴포넌트-클래스형-컴포넌트)
- [9. useCallback / useMemo](#9-usecallback--usememo)
- [10. custom hook의 use case, 장점](#10-custom-hook의-use-case-장점)
- [](#)
- [](#)
- [](#)
- [](#)
- [](#)
- [React](https://github.com/ye-r1/LearnFrontEnd/blob/main/React.md#%EB%AA%A9%EC%B0%A8)
- [Typescript](https://github.com/ye-r1/LearnFrontEnd/blob/main/Typescript.md#%EB%AA%A9%EC%B0%A8)

<br/>

## 내용


### 1. JSX
- `JS XML` 약자
- 자바스크립트 확장 문법
- 자바스크립트와 xml을 혼합해서 사용하는 방식
- `react.createElement( )`을 생성하여 편하게 `html`으로도 작성 가능하게 한다.
`cra`를 하게 되면 `webpack`에서 바벨로 처리해준다.

<br/>

### 2. React
`spa`로 이루어진 프론트앤드 자바스크립트 라이브러리

<br/>

### 3. FLUX
- MVC 패턴의 문제점을 개선한 패턴이다.
- MVC 패턴으로 진행하게되면 규모가 커지면서 Model 관리가 어려워진다.
- 단방향 데이터 흐름을 띄는 아키텍쳐이다. (→ 추적이 쉽다, 관리하기 쉽다)
- UI 데이터만 전달받는다.
- UI 데이터 변경시 직접 `store`와 동기적으로 연결하지 않고, `action`을 일으켜 변경사항을 업데이트한다.


<br/>

### 4. 서버사이드렌더링, 클라이언트사이드렌더링
**서버사이드 렌더링 (SSR)** <br />
> 서버사이드 렌더링`(SSR)` 은 페이지를 이동할 때마다 새로운 페이지를 요청한다.<br />
서버 연산을 통해서 렌더링하고 완성된 페이지 형태로 응답한다.
  
장점<br />
- 페이지를 이동할때마다 서버에 요청한다. => 서버에서 렌더링
- 소스를 전부 불러오기 때문에 검색엔진`(SEO)` 최적화에 좋다.
- 첫 렌더링된 `html` 을 클라이언트에게 전달해 주기때문에 초기 로딩 속도를 많이 줄여 줄 수 있다.
- 자바스크립트 파일을 불러오고 렌더링 작업이 완료되기 전에 사용자가 사이트 컨텐츠를 이용할 수 있게된다.

단점<br />
- 페이지 이동시 깜빡임이 있다.
- 중복리소스와 자원낭비가 심하다.
- 프로젝트가 커지면 복잡할 수 있다.

**클라이언트 사이드 렌더링(CSR)** <br />
> 클라이언트에서 렌더링하는 방식이다. `(Client Side Rendering)`

장점<br />
- 첫 요청할때 한페이지만 불러오게 된다. →  `React` 를 보면 `index.js` 만 불러오게 된다.(Single Page Application)
- 필요한 데이터만 서버에 요청하기 때문에 비교적 트래픽 감소가 있다. => 클라이언트에서 렌더링
- 깜빡이지 않기에 사용자 경험이 올라간다. (`native app`과 동일한 사용경험을 준다.)
- 그 후, 사용자의 행동에 따른 필요한 부분만 다시 읽어들이기 때문에 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있다.
- 페이지 이동시 렌더링이 빠르고, 코드 재사용성이 높다.

단점<br />
- 검색엔진을 최적화 하려면 따로 `SSR` 렌더링이 필요하다.
- `SPA`방식이라 한번에 필요한 데이터를 전부 가져와 초기 속도가 오래 걸린다.

<br />

### 5. 사이트 동작방식
`MPA(Multiple Page Application)`<br/>
가장 전통적인 방식인 MPA 방식이다.<br/>
<br/>
다른페이지로 이동할때 페이지를 다시 요청하여 리소스 낭비가 심하다.<br/>
페이지가 바뀔 때마다 브라우저가 깜빡인다는 단점이 있다.<br/>
<br/>
`SPA(Single Page Application)`는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드한다.<br/>
이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고<br/>
전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다.<br/>
<br/>
모바일의 사용이 증가하고 있는 현 시점에 트래픽의 감소와 속도, 사용성, 반응성의 향상은 매우 중요한 이슈이다.<br/>
`SPA`의 핵심 가치는 사용자 경험(UX) 향상에 있다.

<br />

### 6. 리액트 성능개선 방법

- 첫 페이지 로딩 지연문제를 해결한다. => 첫 페이지의 `SSR` (Server Side Rendering)
- 컴포넌트 `lazy loading`을 추가한다.
- 이미지 `lazy loading`을 추가한다.
- 네트워크 탭의 성능을 추적한다.
- `Re-rendering`을 최소화시킨다.
- 중복계산을 줄인다 (`UseEffect`, `UseMemo`)
- 스켈레톤을 추가한다. (ui-ux 관점)

<br/>


### 7. 프레임워크, 라이브러리
프레임 워크: 어플리케이션 개발을 위한 뼈대, 개발이 빨라진다.<br/>
라이브러리: 어플리케이션의 기능을 빠르게 구현 제공하는 기능, 기능이라 개발 자유도가 높다
<br/>

### 8. 함수형 컴포넌트, 클래스형 컴포넌트
함수형 컴포넌트<br/>
- 짧은 코드로 구현가능한 신문법이다.
- 클래스 컴포넌트 보다 메모리 자원을 덜 사용한다.
- 빌드 후 배포시에 결과물의 크기가 작다.
- `hook` 지원으로 `state` 관리가 쉽다.
- 함수형 컴포넌트는 렌더링된 값들을 고정시킨다.

클래스형 컴포넌트<br/>
- 라이프 사이클 `API`의 사용이 가능하다.
- `render` 함수가 반드시 존재해야 한다.
- `render` 함수가 반드시 존재해야 한다.
<br/>

### 9. useCallback / useMemo
`useMemo` 는 특정 결과값을 재사용 할 때사용하고<br/>
`useCallback` 은 특정 함수를 재사용하고 싶을때 사용한다.<br/>
계속 바뀌는 값에 대해서는 `useMemo`로 최적화를 시켜주고 `deps`를 지정해주어야한다.<br/>
= props로 전달받은 함수는, props나 상태가 업데이트될 때마다 새로 생성이 된다.<br/>
재계산 하는 함수가 아주 간단하다면 성능상의 차이는 미미하겠지만 더 안좋을 수도 있다.<br/>
만약 재계산 하는 로직이 복잡하다면 `useMemo`를 사용함으로써 불필요한 렌더링을 막을 수 있다.

<br/>

### 10. custom hook의 use case, 장점
반복되는 로직을 쉽게 재사용하기 위해 사용하였고, side-effect (부작용)을 방지할 수 있다.

<br/>

<br/><br/>
> 참조 링크<br/>
